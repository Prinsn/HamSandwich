#include "next_soundfile.h"
#include "jamultypes.h"

// NeXT/SUN soundfile.
// Based on this documentation: http://soundfile.sapp.org/doc/NextFormat/
// There is ONE sound in this format in vacationacres.dlw.

// Table source: http://soundfile.sapp.org/doc/NextFormat/mulaw.h
// Definition: https://en.wikipedia.org/wiki/%CE%9C-law_algorithm#Discrete
static const uint16_t muLaw[256] = {
	0x8284, 0x8684, 0x8a84, 0x8e84, 0x9284, 0x9684, 0x9a84, 0x9e84,
	0xa284, 0xa684, 0xaa84, 0xae84, 0xb284, 0xb684, 0xba84, 0xbe84,
	0xc184, 0xc384, 0xc584, 0xc784, 0xc984, 0xcb84, 0xcd84, 0xcf84,
	0xd184, 0xd384, 0xd584, 0xd784, 0xd984, 0xdb84, 0xdd84, 0xdf84,
	0xe104, 0xe204, 0xe304, 0xe404, 0xe504, 0xe604, 0xe704, 0xe804,
	0xe904, 0xea04, 0xeb04, 0xec04, 0xed04, 0xee04, 0xef04, 0xf004,
	0xf0c4, 0xf144, 0xf1c4, 0xf244, 0xf2c4, 0xf344, 0xf3c4, 0xf444,
	0xf4c4, 0xf544, 0xf5c4, 0xf644, 0xf6c4, 0xf744, 0xf7c4, 0xf844,
	0xf8a4, 0xf8e4, 0xf924, 0xf964, 0xf9a4, 0xf9e4, 0xfa24, 0xfa64,
	0xfaa4, 0xfae4, 0xfb24, 0xfb64, 0xfba4, 0xfbe4, 0xfc24, 0xfc64,
	0xfc94, 0xfcb4, 0xfcd4, 0xfcf4, 0xfd14, 0xfd34, 0xfd54, 0xfd74,
	0xfd94, 0xfdb4, 0xfdd4, 0xfdf4, 0xfe14, 0xfe34, 0xfe54, 0xfe74,
	0xfe8c, 0xfe9c, 0xfeac, 0xfebc, 0xfecc, 0xfedc, 0xfeec, 0xfefc,
	0xff0c, 0xff1c, 0xff2c, 0xff3c, 0xff4c, 0xff5c, 0xff6c, 0xff7c,
	0xff88, 0xff90, 0xff98, 0xffa0, 0xffa8, 0xffb0, 0xffb8, 0xffc0,
	0xffc8, 0xffd0, 0xffd8, 0xffe0, 0xffe8, 0xfff0, 0xfff8, 0x0,
	0x7d7c, 0x797c, 0x757c, 0x717c, 0x6d7c, 0x697c, 0x657c, 0x617c,
	0x5d7c, 0x597c, 0x557c, 0x517c, 0x4d7c, 0x497c, 0x457c, 0x417c,
	0x3e7c, 0x3c7c, 0x3a7c, 0x387c, 0x367c, 0x347c, 0x327c, 0x307c,
	0x2e7c, 0x2c7c, 0x2a7c, 0x287c, 0x267c, 0x247c, 0x227c, 0x207c,
	0x1efc, 0x1dfc, 0x1cfc, 0x1bfc, 0x1afc, 0x19fc, 0x18fc, 0x17fc,
	0x16fc, 0x15fc, 0x14fc, 0x13fc, 0x12fc, 0x11fc, 0x10fc, 0xffc,
	0xf3c, 0xebc, 0xe3c, 0xdbc, 0xd3c, 0xcbc, 0xc3c, 0xbbc,
	0xb3c, 0xabc, 0xa3c, 0x9bc, 0x93c, 0x8bc, 0x83c, 0x7bc,
	0x75c, 0x71c, 0x6dc, 0x69c, 0x65c, 0x61c, 0x5dc, 0x59c,
	0x55c, 0x51c, 0x4dc, 0x49c, 0x45c, 0x41c, 0x3dc, 0x39c,
	0x36c, 0x34c, 0x32c, 0x30c, 0x2ec, 0x2cc, 0x2ac, 0x28c,
	0x26c, 0x24c, 0x22c, 0x20c, 0x1ec, 0x1cc, 0x1ac, 0x18c,
	0x174, 0x164, 0x154, 0x144, 0x134, 0x124, 0x114, 0x104,
	0xf4, 0xe4, 0xd4, 0xc4, 0xb4, 0xa4, 0x94, 0x84,
	0x78, 0x70, 0x68, 0x60, 0x58, 0x50, 0x48, 0x40,
	0x38, 0x30, 0x28, 0x20, 0x18, 0x10, 0x8, 0x0
};
// Actually this table makes it sound a little different than it does according
// to ffmpeg, but it's close enough.

owned::Mix_Chunk LoadNextSoundfile(SDL_RWops *rw)
{
	char magic[4];
	int64_t start = SDL_RWtell(rw);
	if (SDL_RWread(rw, magic, 4, 1) == 1)
	{
		if (!memcmp(magic, ".snd", 4) /* Indicates big-endian file. */)
		{
			uint32_t dataLocation = SDL_ReadBE32(rw);
			uint32_t dataSize = SDL_ReadBE32(rw);
			uint32_t dataFormat = SDL_ReadBE32(rw);
			uint32_t samplingRate = SDL_ReadBE32(rw);
			uint32_t channelCount = SDL_ReadBE32(rw);
			SDL_RWseek(rw, start + dataLocation, RW_SEEK_SET);  // Skip info field.

			if (dataFormat == 1 /* SND_FORMAT_MULAW_8 */)
			{
				// Prepare a conversion from e.g. 8012Hz 16-bit mono to our native output format.
				int freq, channels;
				uint16_t format;
				Mix_QuerySpec(&freq, &format, &channels);

				SDL_AudioCVT cvt;
				SDL_BuildAudioCVT(&cvt, AUDIO_S16SYS, channelCount, samplingRate, format, channels, freq);
				cvt.len = dataSize * 2;
				cvt.buf = (byte*) SDL_malloc(cvt.len * cvt.len_mult);

				// Convert 8-bit mulaw to 16-bit samples.
				for (uint32_t i = 0; i < dataSize; ++i)
				{
					uint16_t value = muLaw[SDL_ReadU8(rw)];
					memcpy(&cvt.buf[i * 2], &value, 2);
				}

				// Run the 16-bit to raw conversion and commit it to a chunk.
				SDL_ConvertAudio(&cvt);
				owned::Mix_Chunk output { Mix_QuickLoad_RAW(cvt.buf, cvt.len_cvt) };
				output->allocated = true;
				return output;
			}
			else
			{
				SDL_SetError("NeXT formats other than SND_FORMAT_MULAW_8 not supported");
				return nullptr;
			}
		}
	}

	SDL_SetError("not a .snd file");
	return nullptr;
}
